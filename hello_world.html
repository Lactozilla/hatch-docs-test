<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hatch Game Engine Documentation: Hello World Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Hatch Game Engine Documentation<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">The documentation for the Hatch Game Engine</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('hello_world.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Hello World Tutorial</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this tutorial, you will create your first Hatch game, and learn a few fundamental concepts along the way.</p>
<h2><a class="anchor" id="installing-hatch"></a>
Installing Hatch</h2>
<p>As of writing, there is no official installer for Hatch, but you can compile it yourself. <a href="https://github.com/HatchGameEngine/HatchGameEngine/blob/master/README.md">The readme</a> contains instructions for supported platforms.</p>
<p>For this tutorial, you will need a build with <code>DEVELOPER_MODE</code> enabled, or a debug build.</p>
<h2><a class="anchor" id="the-hatch-scripting-language"></a>
The Hatch Scripting Language</h2>
<p>The Hatch Scripting Language is an <b>object-oriented</b> programming language created for use in Hatch. It emphasizes the use of <b>classes</b> to code entities, and provides facilities found in other programming languages you may already be familiar with. Features of HSL include:</p>
<ul>
<li>A syntax reminiscent of JavaScript.</li>
<li>Dynamic typing.</li>
<li>Integer and floating point number types.</li>
<li>Arrays, maps, and enumerations.</li>
<li>Class-based inheritance.</li>
<li>Class extension, without the need to create a subclass.</li>
<li>A standard library provided by the engine.</li>
<li>I/O streams.</li>
</ul>
<p>Most of your Hatch scripts will be the definition of one or more classes. Entities are defined by their classes, and spawning an entity is merely the same as instantiating a class. Let's create our first script, an entity that displays something to the screen and can be moved around.</p>
<p>Before doing anything, we need to setup our project's folders. Go to the root of your project, and create a folder named <code>Resources</code> in it. Inside of that folder, create an <code>Objects</code> folder. Hatch uses a bytecode virtual machine to execute HSL code, so it needs to compile script files before executing them. This folder is where Hatch will output the compiled scripts to.</p>
<p>Now, go back to the root of your project, and create a <code>Scripts</code> folder. Inside of it, create a file named <code>init.hsl</code>. Your folders should be looking similar to this arrangement:</p>
<div class="fragment"><div class="line">Resources/</div>
<div class="line">    Objects/</div>
<div class="line">Scripts/</div>
<div class="line">    init.hsl</div>
<div class="line">&lt;Hatch executable&gt;</div>
</div><!-- fragment --><p><code>init.hsl</code> is the entry point of a Hatch game. This script is executed once, when the game starts, before any scene is loaded. In any script file, the <b>top-level code</b> is executed whenever said script is loaded. When the script belonging to a specific class has not yet been loaded, the top-level code of that script is ran before the instance is created. This is how code written for an instance gets 'bound' to it: running top-level code defines a class, and the functions of that class are later called by the engine.</p>
<p>In your text editor, add the following to your new <code>init.hsl</code> file:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Square {</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">new</span> Square();</div>
</div><!-- fragment --><p>Here, we are defining a class for <code>Square</code> with nothing in it, and creating a new instance of it. The <code>new</code> keyword is used to create an instance of a given class. To make it do something, though, we need to give it <b>events</b>. Those are functions or methods called by Hatch, the instance itself, or some other code. Let's make our Square print something to the log file whenever it's instanced:</p>
<div class="fragment"><div class="line"> class Square {</div>
<div class="line">+    event Square() {</div>
<div class="line">+        print &quot;Hello, world!&quot;;</div>
<div class="line">+    }</div>
<div class="line"> }</div>
</div><!-- fragment --><p>The <code>event</code> keyword defines an event called <code>Square</code>. Any event whose name matches the name of its class is its constructor. This will be called whenever an instance of <code>Square</code> is created. Inside that event, the <code>print</code> keyword is used to print the string <code>"Hello, world!"</code>.</p>
<p>Now, run Hatch. Since we don't have anything other than our Square, you will see a black screen, although there is text being printed to the log file. If you don't know where that is located, navigate to <code>USERPROFILE%\AppData\Local\hatch\</code> on Windows, or <code>$HOME/.local/state/hatch/</code> on Linux. (<code>$XDG_STATE_HOME/hatch/</code> is also a valid path.) You'll see a <code>HatchGameEngine.log</code> file. When you open it, this will be its last line:</p>
<div class="fragment"><div class="line">INFO: &quot;Hello, world!&quot;</div>
</div><!-- fragment --><p>Success! We defined our first class, and made Hatch execute its code. If you look in the <code>Resources/Objects/</code> directory, you'll notice the following files were created:</p>
<div class="fragment"><div class="line">Resources/</div>
<div class="line">    Objects/</div>
<div class="line">        FDD03353.ibc</div>
<div class="line">        Objects.hcm</div>
</div><!-- fragment --><p>Hatch needs to compile your HSL scripts into <b>bytecode</b> before being able to execute them. The <code>FDD03353.ibc</code> file is the compiled bytecode for the <code>init.hsl</code> script, and <code>Objects.hcm</code> contains a list of the compiled bytecode. This means you never have to distribute your game with your source scripts, and loading the compiled instructions is more efficient than compiling scripts on the spot. As you create more scripts, Hatch will keep compiling HSL into bytecode.</p>
<h2><a class="anchor" id="the-game-configuration-file"></a>
The Game Configuration File</h2>
<p>The Game Configuration File, or <code>GameConfig.xml</code>, is loaded from the Resources/ folder before any scripts are ran. It contains information about your game, such as its name, version, and developer; and engine configurations like the base screen size, or the framerate. The Game Configuration Page in the Manual has a complete list of what can be changed in <code>GameConfig.xml</code>. Let's create a basic GameConfig that just changes the game's title.</p>
<p>In your Resources/ directory, create a file named <code>GameConfig.xml</code>. Your folders should be looking similar to this arrangement:</p>
<div class="fragment"><div class="line">Resources/</div>
<div class="line">    Objects/</div>
<div class="line">        ...</div>
<div class="line">    GameConfig.xml</div>
<div class="line">Scripts/</div>
<div class="line">    init.hsl</div>
<div class="line">&lt;Hatch executable&gt;</div>
</div><!-- fragment --><p>Open <code>GameConfig.xml</code> in your text editor, and copy this text into it:</p>
<div class="fragment"><div class="line">&lt;?<span class="keyword">xml</span> <span class="keyword">version</span>=<span class="stringliteral">&quot;1.0&quot;</span> <span class="keyword">encoding</span>=<span class="stringliteral">&quot;UTF-8&quot;</span>?&gt;</div>
<div class="line">&lt;<span class="keywordtype">gameconfig</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">My</span> <span class="keyword">Hatch</span> <span class="keyword">Game</span>&lt;/<span class="keywordtype">name</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">gameconfig</span>&gt;</div>
</div><!-- fragment --><p>Save the file, and reopen Hatch. The title of your window will change to match the name of the game:</p>
<p><img src="tutorial-1.png" alt="Hatch window with a black screen" class="inline"/></p>
<p>This will also change the location of your log file. To find it, navigate to <code>USERPROFILE%\AppData\Local\My Hatch Game\</code> on Windows, or either <code>$HOME/.local/state/My Hatch Game/</code> or <code>$XDG_STATE_HOME/My Hatch Game/</code> on Linux.</p>
<h2><a class="anchor" id="entities-and-methods"></a>
Entities and methods</h2>
<p>Since we are planning to display something to the screen, an instance won't be enough. As mentioned in the Introduction chapter, a scene is compromised of entities, and an entity is merely an instance managed by a scene. The scene knows that it should execute the code of an entity, which includes rendering it. This is possible because there are specific methods the engine looks for in a class, and calls them. In our case, we need to write a <code>Render</code> method. We will also learn what other methods Hatch calls during the scene lifecycle.</p>
<p>Let's go back to our <code>init.hsl</code> script. Replace <code>new Square();</code> with this:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classInstance.html">Instance</a>.<a class="code hl_function" href="classInstance.html#ac8ccea0b48c663ac42dd47363e243992">Create</a>(<span class="stringliteral">&quot;Square&quot;</span>, 0.0, 0.0);</div>
<div class="ttc" id="aclassInstance_html"><div class="ttname"><a href="classInstance.html">Instance</a></div><div class="ttdoc">General Entity related functions.</div><div class="ttdef"><b>Definition</b> Instance.dox:8</div></div>
<div class="ttc" id="aclassInstance_html_ac8ccea0b48c663ac42dd47363e243992"><div class="ttname"><a href="classInstance.html#ac8ccea0b48c663ac42dd47363e243992">Instance.Create</a></div><div class="ttdeci">Entity Create(string className, number x, number y, value flag=0)</div><div class="ttdoc">Creates a new instance of an object class, and calls its Create event with the flag.</div></div>
</div><!-- fragment --><p>Then press F5. When developer mode is enabled, the F5 key recompiles your code and restarts execution, without you having to close and reopen Hatch. The exact key this is bound to can be changed in the GameConfig or the settings file.</p>
<p>You should see the same message as before in your log file. We can now make the <code>Square</code> show something to the screen! Remove the code inside <code>event Square</code>, so that it no longer prints our message:</p>
<div class="fragment"><div class="line"> class Square {</div>
<div class="line">-    event Square() {</div>
<div class="line">-        print &quot;Hello, world!&quot;;</div>
<div class="line">-    }</div>
<div class="line"> }</div>
</div><!-- fragment --><p>And now, we're going to create a <code>Render</code> event. Below the block of the event we already have (not inside), add this piece of code:</p>
<div class="fragment"><div class="line"><span class="keyword">event</span> Render() {</div>
<div class="line">    <a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#a01c6bc53ee06c86875dc3d225503aa00">SetBlendColor</a>(1.0, 0.0, 0.0, 1.0);</div>
<div class="line">    <a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#a80f6f5b8e0859f4cae73dc5315ecd930">Rectangle</a>(this.X, this.Y, 64.0, 64.0);</div>
<div class="line">}</div>
<div class="ttc" id="aclassDraw_html"><div class="ttname"><a href="classDraw.html">Draw</a></div><div class="ttdoc">General drawing functions.</div><div class="ttdef"><b>Definition</b> Draw.dox:9</div></div>
<div class="ttc" id="aclassDraw_html_a01c6bc53ee06c86875dc3d225503aa00"><div class="ttname"><a href="classDraw.html#a01c6bc53ee06c86875dc3d225503aa00">Draw.SetBlendColor</a></div><div class="ttdeci">void SetBlendColor(integer hex, number alpha)</div><div class="ttdoc">Sets the color to be used for drawing and blending.</div></div>
<div class="ttc" id="aclassDraw_html_a80f6f5b8e0859f4cae73dc5315ecd930"><div class="ttname"><a href="classDraw.html#a80f6f5b8e0859f4cae73dc5315ecd930">Draw.Rectangle</a></div><div class="ttdeci">void Rectangle(number x, number y, number width, number height)</div><div class="ttdoc">Draws a rectangle.</div></div>
</div><!-- fragment --><p>Your script should be looking like this:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Square {</div>
<div class="line">    <span class="keyword">event</span> Square() {</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">event</span> Render() {</div>
<div class="line">        <a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#a01c6bc53ee06c86875dc3d225503aa00">SetBlendColor</a>(1.0, 0.0, 0.0, 1.0);</div>
<div class="line">        <a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#a80f6f5b8e0859f4cae73dc5315ecd930">Rectangle</a>(this.X, this.Y, 64.0, 64.0);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Recompile your code by pressing F5. You should see this:</p>
<p><img src="tutorial-2.png" alt="Black screen with a red square on the top left corner" class="inline"/></p>
<p>The <a class="el" href="classDraw.html#a01c6bc53ee06c86875dc3d225503aa00">Draw.SetBlendColor</a> method sets the current color used for drawing. We passed (<code>1.0</code>, <code>0.0</code>, <code>0.0</code>, <code>1.0</code>), so the current color is now a solid red.</p>
<p><a class="el" href="classDraw.html#a01c6bc53ee06c86875dc3d225503aa00">Draw.SetBlendColor</a> also supports a different way of calling it, where you instead pass an integer representing an RGB color, plus a decimal representing the alpha value:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#a01c6bc53ee06c86875dc3d225503aa00">SetBlendColor</a>(0xFF0000, 1.0);</div>
</div><!-- fragment --><p>Next, we called <a class="el" href="classDraw.html#a80f6f5b8e0859f4cae73dc5315ecd930">Draw.Rectangle</a> using <code>this.X</code> and <code>this.Y</code> as the first two arguments. <code>this</code> refers to the instance of the Square, and <code>X</code> and <code>Y</code> are the coordinates of the Square entity. Remember what you wrote in <code>init.hsl</code>? This line:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classInstance.html">Instance</a>.<a class="code hl_function" href="classInstance.html#ac8ccea0b48c663ac42dd47363e243992">Create</a>(<span class="stringliteral">&quot;Square&quot;</span>, 0.0, 0.0);</div>
</div><!-- fragment --><p>The second and third parameters are the X of Y position of where to spawn the entity. Since both are <code>0.0</code>, this places the entity on the top left corner of the scene. Finally, the last two parameters passed to <a class="el" href="classDraw.html#a80f6f5b8e0859f4cae73dc5315ecd930">Draw.Rectangle</a> are the width and height of the rectangle.</p>
<p>Let's change the position of the square. Change the second and third arguments passed to <a class="el" href="classInstance.html#ac8ccea0b48c663ac42dd47363e243992">Instance.Create</a>, like so:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classInstance.html">Instance</a>.<a class="code hl_function" href="classInstance.html#ac8ccea0b48c663ac42dd47363e243992">Create</a>(<span class="stringliteral">&quot;Square&quot;</span>, 48.0, 48.0);</div>
</div><!-- fragment --><p>Press F5, and you should see this:</p>
<p><img src="tutorial-3.png" alt="Black screen with a red square close to the top left corner" class="inline"/></p>
<p>The square is no longer at the very corner of the screen, since we changed its position on the scene.</p>
<h3><a class="anchor" id="instance-fields"></a>
Instance fields</h3>
<p>Like all object-oriented programming languages, any instance will have fields you can set and get. When you spawn an entity, Hatch will provide to the instance built-in fields like <code>X</code> and <code>Y</code>, but we can also make up our own. Let's make it so that we can manipulate the color of the square using fields.</p>
<p>This is also a good time to mention that Hatch calls the <code>Create</code> method on any new entity. When it was a plain instance, we used the constructor, but with entities, Hatch calls both the constructor and <code>Create</code>. The difference is that the constructor is ran before <code>Create</code>, though currently this is not relevant. Either way, let's rename our <code>event Square()</code> so that it's a <code>Create</code> instead.</p>
<div class="fragment"><div class="line"> class Square {</div>
<div class="line">-    event Square() {</div>
<div class="line">+    event Create() {</div>
<div class="line"> </div>
<div class="line">     }</div>
<div class="line"> </div>
<div class="line">     event Render() {</div>
<div class="line">         Draw.SetBlendColor(1.0, 0.0, 0.0, 1.0);</div>
<div class="line">         Draw.Rectangle(this.X, this.Y, 64.0, 64.0);</div>
<div class="line">     }</div>
<div class="line"> }</div>
</div><!-- fragment --><p>Now, we'll initialize four different variables for each argument that will be passed to Draw.Rectangle:</p>
<div class="fragment"><div class="line"><span class="keyword">event</span> Create() {</div>
<div class="line">    this.RedColor = 1.0;</div>
<div class="line">    this.GreenColor = 0.0;</div>
<div class="line">    this.BlueColor = 0.0;</div>
<div class="line">    this.AlphaColor = 1.0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here they are named <code>RedColor</code>, <code>GreenColor</code>, <code>BlueColor</code>, and <code>AlphaColor</code> for general consistency with HSL's style, but you can give them other names, of course. The next step is to change the <a class="el" href="classDraw.html#a01c6bc53ee06c86875dc3d225503aa00">Draw.SetBlendColor</a> call to use the variables we defined.</p>
<div class="fragment"><div class="line"> event Render() {</div>
<div class="line">-    Draw.SetBlendColor(1.0, 0.0, 0.0, 1.0);</div>
<div class="line">+    Draw.SetBlendColor(this.RedColor, this.GreenColor, this.BlueColor, this.AlphaColor);</div>
<div class="line">     Draw.Rectangle(this.X, this.Y, 64.0, 64.0);</div>
<div class="line"> }</div>
</div><!-- fragment --><p>Press F5. It should look the exact same, but we'll add code to make the player able to manipulate its color.</p>
<h2><a class="anchor" id="input-handling"></a>
Input handling</h2>
<p>Giving control to the player is necessary in any game, and Hatch listens to various types of devices for input. Generally, you do this through certain methods in the <a class="el" href="classInput.html">Input</a> class. You could manually check if a given keyboard key or controller button is being pressed, or if a controller axis is being moved in a given direction, but Hatch already has a system to handle all of this in place. Those are called <b>input actions</b>. If that sounds familiar to you, Godot and Unity have a similar system with the exact name, and they have the same goal. Input actions abstract what the player actually does (press a key, move an analog stick, scroll the mouse wheel) into some kind of game-specific action, like move a character, or navigate through a menu.</p>
<p>You can define your game's set of input actions using GameConfig, but since version 1.4, Hatch provides a set of default input actions:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Action   </th><th class="markdownTableHeadNone">Keyboard key   </th><th class="markdownTableHeadNone">Controller button   </th><th class="markdownTableHeadNone">Controller axis    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Up</code>   </td><td class="markdownTableBodyNone">Up arrow   </td><td class="markdownTableBodyNone">D-Pad up   </td><td class="markdownTableBodyNone">Left stick up    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Down</code>   </td><td class="markdownTableBodyNone">Down arrow   </td><td class="markdownTableBodyNone">D-Pad down   </td><td class="markdownTableBodyNone">Left stick down    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Left</code>   </td><td class="markdownTableBodyNone">Left arrow   </td><td class="markdownTableBodyNone">D-Pad left   </td><td class="markdownTableBodyNone">Left stick left    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Right</code>   </td><td class="markdownTableBodyNone">Right arrow   </td><td class="markdownTableBodyNone">D-Pad right   </td><td class="markdownTableBodyNone">Left stick right    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>A</code>   </td><td class="markdownTableBodyNone">A   </td><td class="markdownTableBodyNone">Bottom face button   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>B</code>   </td><td class="markdownTableBodyNone">S   </td><td class="markdownTableBodyNone">Right face button   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>C</code>   </td><td class="markdownTableBodyNone">D   </td><td class="markdownTableBodyNone">Left shoulder   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>X</code>   </td><td class="markdownTableBodyNone">Q   </td><td class="markdownTableBodyNone">Left face button   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Y</code>   </td><td class="markdownTableBodyNone">W   </td><td class="markdownTableBodyNone">Top face button   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Z</code>   </td><td class="markdownTableBodyNone">E   </td><td class="markdownTableBodyNone">Right shoulder   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Start</code>   </td><td class="markdownTableBodyNone">Enter (Return)   </td><td class="markdownTableBodyNone">Start   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Select</code>   </td><td class="markdownTableBodyNone">Tab   </td><td class="markdownTableBodyNone">Back (or Select)   </td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>All actions have binds for both keyboard and controller, so if you have a controller plugged in, you'll be able to use it here.</p>
<p>Generally, you'll be using the following methods to check for input: <a class="el" href="classInput.html#a779387761a7a9f4eff3928b7d82dd6f8">Input.IsActionHeld</a>, <a class="el" href="classInput.html#a345a02f855bdd72604fbb4bfb3eb9cc2">Input.IsActionPressed</a>, and <a class="el" href="classInput.html#a29b08c41dd7aba4b3706df3796e0fc30">Input.IsActionReleased</a>. Let's do something basic and write some code that changes the color of the square whenever the player presses (not holds) left or right.</p>
<p>Add an <code>Update</code> method to the class. <code>Update</code> is usually called for all entities on the scene, each frame. Inside it, we'll check for player input:</p>
<div class="fragment"><div class="line"><span class="keyword">event</span> Update() {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_class" href="classInput.html">Input</a>.<a class="code hl_function" href="classInput.html#a345a02f855bdd72604fbb4bfb3eb9cc2">IsActionPressed</a>(0, <span class="stringliteral">&quot;Right&quot;</span>)) {</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassInput_html"><div class="ttname"><a href="classInput.html">Input</a></div><div class="ttdoc">Input polling functions.</div><div class="ttdef"><b>Definition</b> Input.dox:9</div></div>
<div class="ttc" id="aclassInput_html_a345a02f855bdd72604fbb4bfb3eb9cc2"><div class="ttname"><a href="classInput.html#a345a02f855bdd72604fbb4bfb3eb9cc2">Input.IsActionPressed</a></div><div class="ttdeci">boolean IsActionPressed(integer playerID, string actionName, InputDevice inputDevice)</div><div class="ttdoc">Gets whether the input action is currently pressed for the specified player.</div></div>
</div><!-- fragment --><p>The first parameter is the player index to check. This is zero-based. There is only one player, so we pass <code>0</code>. You may use <a class="el" href="classInput.html#ab7ebba75ddff9037825d78a8baed856f">Input.IsActionPressedByAny</a> to check if <em>any</em> player is pressing a specific action. The second parameter is the name of the input action to check. In this case, <code>Right</code>. If the first player is pressing right on their keyboard or controller, this call returns true.</p>
<p>Now let's make it so that pressing right gradually changes the color of the square from red to blue.</p>
<div class="fragment"><div class="line"><span class="keyword">event</span> Update() {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_class" href="classInput.html">Input</a>.<a class="code hl_function" href="classInput.html#a345a02f855bdd72604fbb4bfb3eb9cc2">IsActionPressed</a>(0, <span class="stringliteral">&quot;Right&quot;</span>)) {</div>
<div class="line">        this.RedColor -= 0.1;</div>
<div class="line">        this.BlueColor += 0.1;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (this.RedColor &lt; 0.0) {</div>
<div class="line">            this.RedColor = 0.0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (this.BlueColor &gt; 1.0) {</div>
<div class="line">            this.BlueColor = 1.0;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you recompile your code, then press right enough times, the square should be blue.</p>
<p> 
<video controls>
    <source src="tutorial-4.mp4" type="video/mp4">
</video>
</p>
<p>To turn the square red, we do the opposite of the above code snippet, and check if <code>Left</code> is being pressed instead.</p>
<div class="fragment"><div class="line"> event Update() {</div>
<div class="line">+    if (Input.IsActionPressed(0, &quot;Left&quot;)) {</div>
<div class="line">+        this.RedColor += 0.1;</div>
<div class="line">+        this.BlueColor -= 0.1;</div>
<div class="line"> </div>
<div class="line">+        if (this.RedColor &gt; 1.0) {</div>
<div class="line">+            this.RedColor = 1.0;</div>
<div class="line">+        }</div>
<div class="line">+        if (this.BlueColor &lt; 0.0) {</div>
<div class="line">+            this.BlueColor = 0.0;</div>
<div class="line">+        }</div>
<div class="line">+    }</div>
<div class="line">     if (Input.IsActionPressed(0, &quot;Right&quot;)) {</div>
</div><!-- fragment --><p>Recompile your code, and try pressing right and left. You'll be able to change the color of the square to blue or red.</p>
<p> 
<video controls>
    <source src="tutorial-5.mp4" type="video/mp4">
</video>
</p>
<p>Now that you know the basics of input actions, we can do a little more with this square, such as allowing the player to move it around. Hatch's coordinate system places (0, 0) at the top left corner of the scene, with X increasing moving to the right, and Y moving down. In <code>Update</code>, we add code to check if <code>Up</code>, <code>Down</code>, <code>Left</code> or <code>Right</code> are being <em>held</em>, and if so, we increment or decrement <code>X</code> and <code>Y</code> by a certain amount. For now, let's change <code>Left</code> and <code>Right</code> in the code that changes the square's color to refer to different input actions, like <code>A</code> and <code>B</code>.</p>
<div class="fragment"><div class="line"> event Update() {</div>
<div class="line">+    if (Input.IsActionHeld(0, &quot;Up&quot;)) {</div>
<div class="line">+        this.Y -= 2.0;</div>
<div class="line">+    }</div>
<div class="line">+    if (Input.IsActionHeld(0, &quot;Down&quot;)) {</div>
<div class="line">+        this.Y += 2.0;</div>
<div class="line">+    }</div>
<div class="line">+    if (Input.IsActionHeld(0, &quot;Left&quot;)) {</div>
<div class="line">+        this.X -= 2.0;</div>
<div class="line">+    }</div>
<div class="line">+    if (Input.IsActionHeld(0, &quot;Right&quot;)) {</div>
<div class="line">+        this.X += 2.0;</div>
<div class="line">+    }</div>
<div class="line">-    if (Input.IsActionPressed(0, &quot;Left&quot;)) {</div>
<div class="line">+    if (Input.IsActionPressed(0, &quot;A&quot;)) {</div>
<div class="line">         [...]</div>
<div class="line">     }</div>
<div class="line">-    if (Input.IsActionPressed(0, &quot;Right&quot;)) {</div>
<div class="line">+    if (Input.IsActionPressed(0, &quot;B&quot;)) {</div>
<div class="line">         [...]</div>
<div class="line">     }</div>
<div class="line"> }</div>
</div><!-- fragment --><p>If you recompile your code and press the arrow keys (or the D-Pad in your controller) you will be able to move the square around.</p>
<p> 
<video controls>
    <source src="tutorial-6.mp4" type="video/mp4">
</video>
</p>
<p>Note that Hatch has no way of knowing those are directional inputs, so the player will be able to hold opposite cardinal directions. You'll want to handle that in an actual game.</p>
<h2><a class="anchor" id="drawing-an-image"></a>
Drawing an image</h2>
<p>All resources in Hatch are loaded through a Virtual File System. Since we created a Resources/ directory earlier, Hatch mounts this to an internal VFS, and all resources are loaded from that folder. When it's time for you to package your game for distribution, you'll be given options to pack your resources into a single file, and Hatch supports different formats for resource packing, including its own. The manual provides more details about this functionality.</p>
<p>To load resources like sprites, images and audio, we use the <code>Resources</code> class in the standard library. For image files, the <a class="el" href="classResources.html#a36422921017ac15c03d5259396a08f30">Resources.LoadImage</a> function can open a PNG or GIF file and return an image we can draw. This is the image we'll be using:</p>
<p><img src="hatch.png" alt="Hatch icon" style="float: left;" class="inline"/> </p><div style="clear: left;"></div><p>Save this image into the Resources/ directory. Your folder structure should be looking similar to this:</p>
<div class="fragment"><div class="line">Resources/</div>
<div class="line">    Objects/</div>
<div class="line">    hatch.png</div>
<div class="line">Scripts/</div>
<div class="line">    init.hsl</div>
<div class="line">&lt;Hatch executable&gt;</div>
</div><!-- fragment --><p>Since this won't be a square anymore, let's rename the class to something else:</p>
<div class="fragment"><div class="line">- class Square {</div>
<div class="line">+ class Chick {</div>
</div><!-- fragment --><p>Now, let's load the image using <a class="el" href="classResources.html#a36422921017ac15c03d5259396a08f30">Resources.LoadImage</a> as previously mentioned:</p>
<div class="fragment"><div class="line"> class Chick {</div>
<div class="line">     event Create() {</div>
<div class="line">+        this.HatchImage = Resources.LoadImage(&quot;hatch.png&quot;, SCOPE_SCENE);</div>
<div class="line">         [...]</div>
</div><!-- fragment --><p>The second argument passed to the function is the resource's <b>unload policy</b>. A value of <a class="el" href="group__hsl.html#gga51fb466065610b59ea508dc6d1db1ab8a7f58b024dd1ea5f89f886496b52c33f8">SCOPE_SCENE</a> means the resource will only stay loaded for the lifecycle of the current scene, and a value of <a class="el" href="group__hsl.html#gga51fb466065610b59ea508dc6d1db1ab8ac403a6e4e10ac2145d091501c1a5381e">SCOPE_GAME</a> keeps the resource loaded for the entire game. Which unload policy to use will depend on how often you will need a given asset.</p>
<p>The <a class="el" href="classDraw.html#a96f1966794fbe506ebf6e0d84ebf2075">Draw.Image</a> function can be used to draw an image to the screen. It accepts an image resource and X and Y coordinates as parameters. In <code>Render</code>, replace the line that draws a rectangle with a call to <a class="el" href="classDraw.html#a96f1966794fbe506ebf6e0d84ebf2075">Draw.Image</a> like so:</p>
<div class="fragment"><div class="line"> event Render() {</div>
<div class="line">     Draw.SetBlendColor(this.RedColor, this.GreenColor, this.BlueColor, this.AlphaColor);</div>
<div class="line">-    Draw.Rectangle(this.X, this.Y, 64.0, 64.0);</div>
<div class="line">+    Draw.Image(this.HatchImage, this.X, this.Y);</div>
<div class="line"> }</div>
</div><!-- fragment --><p>Lastly, change the <a class="el" href="classInstance.html#ac8ccea0b48c663ac42dd47363e243992">Instance.Create</a> call to refer to <code>Chick</code>, not <code>Square</code>.</p>
<div class="fragment"><div class="line">- Instance.Create(&quot;Square&quot;, 48.0, 48.0);</div>
<div class="line">+ Instance.Create(&quot;Chick&quot;, 48.0, 48.0);</div>
</div><!-- fragment --><p>Press F5. You should see the Hatch logo on the screen instead of a red square.</p>
<p><img src="tutorial-7.png" alt="Black screen with the Hatch logo on it" class="inline"/></p>
<h3><a class="anchor" id="blending"></a>
Blending</h3>
<p>Even though our <code>Render</code> function still has a call to <a class="el" href="classDraw.html#a01c6bc53ee06c86875dc3d225503aa00">Draw.SetBlendColor</a>, the Hatch logo is being drawn in its usual colors, instead of being tinted red or blue. The reason is that, normally, bitmaps drawn to the screen (such as images and sprites) aren't blended with the current color, and you have to tell Hatch to do so. This is possible through calling <a class="el" href="classDraw.html#afb8b13bd27d2b371e6e4aca6d8cddf7e">Draw.SetTextureBlend</a>.</p>
<div class="fragment"><div class="line"> event Render() {</div>
<div class="line">+    Draw.SetTextureBlend(true);</div>
<div class="line">     Draw.SetBlendColor(this.RedColor, this.GreenColor, this.BlueColor, this.AlphaColor);</div>
<div class="line">     Draw.Image(this.HatchImage, this.X, this.Y);</div>
<div class="line"> }</div>
</div><!-- fragment --><p>Now if you recompile your code, the Hatch logo will be blended either red or blue.</p>
<p> 
<video controls>
    <source src="tutorial-8.mp4" type="video/mp4">
</video>
</p>
<p>The graphics state persists even after <code>Render</code> finishes execution, so it's good practice to reset it before the function returns.</p>
<div class="fragment"><div class="line"> event Render() {</div>
<div class="line">     Draw.SetTextureBlend(true);</div>
<div class="line">     Draw.SetBlendColor(this.RedColor, this.GreenColor, this.BlueColor, this.AlphaColor);</div>
<div class="line">     Draw.Image(this.HatchImage, this.X, this.Y);</div>
<div class="line">+    Draw.SetBlendColor(1.0, 1.0, 1.0, 1.0);</div>
<div class="line">+    Draw.SetTextureBlend(false);</div>
<div class="line"> }</div>
</div><!-- fragment --><h2><a class="anchor" id="organizing-the-code"></a>
Organizing the code</h2>
<p>Speaking of good practice, it's a good idea to separate classes into their own files. So let's do just that. Currently, this is the contents of our <code>init.hsl</code> file:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Chick {</div>
<div class="line">    <span class="keyword">event</span> Create() {</div>
<div class="line">        this.HatchImage = <a class="code hl_class" href="classResources.html">Resources</a>.<a class="code hl_function" href="classResources.html#a36422921017ac15c03d5259396a08f30">LoadImage</a>(<span class="stringliteral">&quot;hatch.png&quot;</span>, <a class="code hl_enumvalue" href="group__hsl.html#gga51fb466065610b59ea508dc6d1db1ab8a7f58b024dd1ea5f89f886496b52c33f8">SCOPE_SCENE</a>);</div>
<div class="line">        this.RedColor = 1.0;</div>
<div class="line">        this.GreenColor = 0.0;</div>
<div class="line">        this.BlueColor = 0.0;</div>
<div class="line">        this.AlphaColor = 1.0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">event</span> Update() {</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_class" href="classInput.html">Input</a>.<a class="code hl_function" href="classInput.html#a779387761a7a9f4eff3928b7d82dd6f8">IsActionHeld</a>(0, <span class="stringliteral">&quot;Up&quot;</span>)) {</div>
<div class="line">            this.Y -= 2.0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_class" href="classInput.html">Input</a>.<a class="code hl_function" href="classInput.html#a779387761a7a9f4eff3928b7d82dd6f8">IsActionHeld</a>(0, <span class="stringliteral">&quot;Down&quot;</span>)) {</div>
<div class="line">            this.Y += 2.0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_class" href="classInput.html">Input</a>.<a class="code hl_function" href="classInput.html#a779387761a7a9f4eff3928b7d82dd6f8">IsActionHeld</a>(0, <span class="stringliteral">&quot;Left&quot;</span>)) {</div>
<div class="line">            this.X -= 2.0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_class" href="classInput.html">Input</a>.<a class="code hl_function" href="classInput.html#a779387761a7a9f4eff3928b7d82dd6f8">IsActionHeld</a>(0, <span class="stringliteral">&quot;Right&quot;</span>)) {</div>
<div class="line">            this.X += 2.0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_class" href="classInput.html">Input</a>.<a class="code hl_function" href="classInput.html#a345a02f855bdd72604fbb4bfb3eb9cc2">IsActionPressed</a>(0, <span class="stringliteral">&quot;A&quot;</span>)) {</div>
<div class="line">            this.RedColor += 0.1;</div>
<div class="line">            this.BlueColor -= 0.1;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (this.RedColor &gt; 1.0) {</div>
<div class="line">                this.RedColor = 1.0;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (this.BlueColor &lt; 0.0) {</div>
<div class="line">                this.BlueColor = 0.0;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_class" href="classInput.html">Input</a>.<a class="code hl_function" href="classInput.html#a345a02f855bdd72604fbb4bfb3eb9cc2">IsActionPressed</a>(0, <span class="stringliteral">&quot;B&quot;</span>)) {</div>
<div class="line">            this.RedColor -= 0.1;</div>
<div class="line">            this.BlueColor += 0.1;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (this.RedColor &lt; 0.0) {</div>
<div class="line">                this.RedColor = 0.0;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (this.BlueColor &gt; 1.0) {</div>
<div class="line">                this.BlueColor = 1.0;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">event</span> Render() {</div>
<div class="line">        <a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#afb8b13bd27d2b371e6e4aca6d8cddf7e">SetTextureBlend</a>(<span class="keyword">true</span>);</div>
<div class="line">        <a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#a01c6bc53ee06c86875dc3d225503aa00">SetBlendColor</a>(this.RedColor, this.GreenColor, this.BlueColor, this.AlphaColor);</div>
<div class="line">        <a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#a96f1966794fbe506ebf6e0d84ebf2075">Image</a>(this.HatchImage, this.X, this.Y);</div>
<div class="line">        <a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#a01c6bc53ee06c86875dc3d225503aa00">SetBlendColor</a>(1.0, 1.0, 1.0, 1.0);</div>
<div class="line">        <a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#afb8b13bd27d2b371e6e4aca6d8cddf7e">SetTextureBlend</a>(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classInstance.html">Instance</a>.<a class="code hl_function" href="classInstance.html#ac8ccea0b48c663ac42dd47363e243992">Create</a>(<span class="stringliteral">&quot;Chick&quot;</span>, 48.0, 48.0);</div>
<div class="ttc" id="aclassDraw_html_a96f1966794fbe506ebf6e0d84ebf2075"><div class="ttname"><a href="classDraw.html#a96f1966794fbe506ebf6e0d84ebf2075">Draw.Image</a></div><div class="ttdeci">void Image(integer image, number x, number y, integer paletteID)</div><div class="ttdoc">Draws an image.</div></div>
<div class="ttc" id="aclassDraw_html_afb8b13bd27d2b371e6e4aca6d8cddf7e"><div class="ttname"><a href="classDraw.html#afb8b13bd27d2b371e6e4aca6d8cddf7e">Draw.SetTextureBlend</a></div><div class="ttdeci">void SetTextureBlend(boolean doBlend)</div><div class="ttdoc">Sets whether to use color and alpha blending on sprites, images, and textures.</div></div>
<div class="ttc" id="aclassInput_html_a779387761a7a9f4eff3928b7d82dd6f8"><div class="ttname"><a href="classInput.html#a779387761a7a9f4eff3928b7d82dd6f8">Input.IsActionHeld</a></div><div class="ttdeci">boolean IsActionHeld(integer playerID, string actionName, InputDevice inputDevice)</div><div class="ttdoc">Gets whether the input action is currently held for the specified player.</div></div>
<div class="ttc" id="aclassResources_html"><div class="ttname"><a href="classResources.html">Resources</a></div><div class="ttdoc">Resource loading.</div><div class="ttdef"><b>Definition</b> Resources.dox:8</div></div>
<div class="ttc" id="aclassResources_html_a36422921017ac15c03d5259396a08f30"><div class="ttname"><a href="classResources.html#a36422921017ac15c03d5259396a08f30">Resources.LoadImage</a></div><div class="ttdeci">integer LoadImage(string filename, integer unloadPolicy)</div><div class="ttdoc">Loads an Image resource, returning its Image index.</div></div>
<div class="ttc" id="agroup__hsl_html_gga51fb466065610b59ea508dc6d1db1ab8a7f58b024dd1ea5f89f886496b52c33f8"><div class="ttname"><a href="group__hsl.html#gga51fb466065610b59ea508dc6d1db1ab8a7f58b024dd1ea5f89f886496b52c33f8">SCOPE_SCENE</a></div><div class="ttdeci">@ SCOPE_SCENE</div><div class="ttdef"><b>Definition</b> SCOPE.hsl:12</div></div>
</div><!-- fragment --><p>We'll be moving the class's code into its own file, leaving <code>init.hsl</code> to only deal with spawning the entity. In <code>Scripts</code>, create a file named <code>Chick.hsl</code>, and move the definition of the <code>Chick</code> class into it. If done correctly, your scripts should be laid out like this:</p>
<p><code>Chick.hsl</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Chick {</div>
<div class="line">    <span class="keyword">event</span> Create() {</div>
<div class="line">        this.HatchImage = <a class="code hl_class" href="classResources.html">Resources</a>.<a class="code hl_function" href="classResources.html#a36422921017ac15c03d5259396a08f30">LoadImage</a>(<span class="stringliteral">&quot;hatch.png&quot;</span>, <a class="code hl_enumvalue" href="group__hsl.html#gga51fb466065610b59ea508dc6d1db1ab8a7f58b024dd1ea5f89f886496b52c33f8">SCOPE_SCENE</a>);</div>
<div class="line">        this.RedColor = 1.0;</div>
<div class="line">        this.GreenColor = 0.0;</div>
<div class="line">        this.BlueColor = 0.0;</div>
<div class="line">        this.AlphaColor = 1.0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">event</span> Update() {</div>
<div class="line">        <span class="comment">// Omitted for brevity...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">event</span> Render() {</div>
<div class="line">        <a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#afb8b13bd27d2b371e6e4aca6d8cddf7e">SetTextureBlend</a>(<span class="keyword">true</span>);</div>
<div class="line">        <a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#a01c6bc53ee06c86875dc3d225503aa00">SetBlendColor</a>(this.RedColor, this.GreenColor, this.BlueColor, this.AlphaColor);</div>
<div class="line">        <a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#a96f1966794fbe506ebf6e0d84ebf2075">Image</a>(this.HatchImage, this.X, this.Y);</div>
<div class="line">        <a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#a01c6bc53ee06c86875dc3d225503aa00">SetBlendColor</a>(1.0, 1.0, 1.0, 1.0);</div>
<div class="line">        <a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#afb8b13bd27d2b371e6e4aca6d8cddf7e">SetTextureBlend</a>(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>init.hsl</code>:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classInstance.html">Instance</a>.<a class="code hl_function" href="classInstance.html#ac8ccea0b48c663ac42dd47363e243992">Create</a>(<span class="stringliteral">&quot;Chick&quot;</span>, 48.0, 48.0);</div>
</div><!-- fragment --><p>Press F5. Since you just refactored the code, it should work like it did before. Also, Hatch still loaded our <code>Chick</code> class, without you needing to "import" it. This is because the engine automatically loads any class passed to <a class="el" href="classInstance.html#ac8ccea0b48c663ac42dd47363e243992">Instance.Create</a>. Additionally, if you have been paying attention to the <code>Resources/Objects/</code> directory, you'll see that a new <code>.ibc</code> file was created:</p>
<div class="fragment"><div class="line">Resources/</div>
<div class="line">    Objects/</div>
<div class="line">        90F6C701.ibc &lt;--- This is new</div>
<div class="line">        FDD03353.ibc</div>
<div class="line">        Objects.hcm</div>
</div><!-- fragment --><p>Like previously mentioned, Hatch will compile code for new script files you create, without you having to tell it to do so.</p>
<h2><a class="anchor" id="loading-a-scene-file"></a>
Loading a scene file</h2>
<p>By default, Hatch will load an empty scene, but you can specify a scene file. The engine can read Tiled's map format (TMX) and supports a decent amount of features. Download the following files and move them into the <code>Resources</code> directory:</p>
<p><a href="scene.tmx">scene.tmx</a> <br  />
 <a href="tileset.png">tileset.png</a> <br  />
 <a href="background.png">background.png</a> <br  />
</p>
<p>The <code>scene.tmx</code> file is the scene file we'll be loading. It's pretty simple; it has only two layers, and one object, the chick. The tileset images are the files <code>tileset.png</code> and <code>background.png</code>. Hatch supports loading external Tiled tileset files (TSX) if specified by the map, but <code>scene.tmx</code> stores its tileset internally.</p>
<p>Go back to <code>init.hsl</code>. Remove the call to <a class="el" href="classInstance.html#ac8ccea0b48c663ac42dd47363e243992">Instance.Create</a>, and replace it with this:</p>
<div class="fragment"><div class="line">- Instance.Create(&quot;Chick&quot;, 48.0, 48.0);</div>
<div class="line">+ Scene.Load(&quot;scene.tmx&quot;);</div>
</div><!-- fragment --><p>Press F5, and you should see this:</p>
<p><img src="tutorial-9.png" alt="A scene with a background and foreground layer. The background is a night sky in a pixel art style, and the foreground uses an industrial tileset" class="inline"/></p>
<p>The tiles are being displayed, but the chick isn't visible. Why?</p>
<p>In Hatch, layers and entities are displayed using a <b>priority system</b>. Layers render on top of entities, and an entity/layer with a higher priority than another entity/layer is displayed on top of it. By default, all layers and entities have a priority of zero, so the chick is being rendered <em>behind</em> the layers.</p>
<p>Of course, you can change the priority of any layer or entity through a script. For entities, you can change their <a class="el" href="classEntity.html#ab6e1d750ef8528b4645554daf389460c">Entity.Priority</a> field. <code>Create</code> is a good place for this:</p>
<div class="fragment"><div class="line"> event Create() {</div>
<div class="line">     this.HatchImage = Resources.LoadImage(&quot;hatch.png&quot;, SCOPE_SCENE);</div>
<div class="line">+    this.Priority = 1;</div>
<div class="line">     [...]</div>
</div><!-- fragment --><p>The chick should be visible again.</p>
<p><img src="tutorial-10.png" alt="The scene with the Hatch logo on it, tinted red" class="inline"/></p>
<h2><a class="anchor" id="entity-properties"></a>
Entity properties</h2>
<p>Entities spawned through scene files have <b>properties</b> that can be read from a script. The method <a class="el" href="classEntity.html#a4246f27bcd096415b011d9b94bceba52">Entity.PropertyExists</a> checks if a given named property has been set on an entity, and <a class="el" href="classEntity.html#a8b246effa32d3e616187dbd915247727">Entity.PropertyGet</a> gets the value of the property. Hatch supports the following property types when loading a Tiled map:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Tiled type   </th><th class="markdownTableHeadNone">HSL type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>int</code>   </td><td class="markdownTableBodyNone">Integer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>float</code>   </td><td class="markdownTableBodyNone">Decimal    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>bool</code>   </td><td class="markdownTableBodyNone">Integer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>color</code>   </td><td class="markdownTableBodyNone">Integer    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>file</code>   </td><td class="markdownTableBodyNone">String    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>object</code>   </td><td class="markdownTableBodyNone">Integer    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Any other types   </td><td class="markdownTableBodyNone">String   </td></tr>
</table>
<p>In the scene file you downloaded, the Chick object has a <code>blendColor</code> property, which is of the <code>color</code> type. Since properties of type <code>color</code> become integers, we can pass it directly to <a class="el" href="classDraw.html#a01c6bc53ee06c86875dc3d225503aa00">Draw.SetBlendColor</a>. Let's hook this up to the current code we have.</p>
<p>In our <code>Create</code> method, replace these lines:</p>
<div class="fragment"><div class="line">this.RedColor = 1.0;</div>
<div class="line">this.GreenColor = 0.0;</div>
<div class="line">this.BlueColor = 0.0;</div>
<div class="line">this.AlphaColor = 1.0;</div>
</div><!-- fragment --><p>...with this code:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (this.PropertyExists(<span class="stringliteral">&quot;blendColor&quot;</span>)) {</div>
<div class="line">    this.Color = this.PropertyGet(<span class="stringliteral">&quot;blendColor&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> {</div>
<div class="line">    this.Color = 0xFFFFFF;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In <code>Update</code>, remove these lines:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_class" href="classInput.html">Input</a>.<a class="code hl_function" href="classInput.html#a345a02f855bdd72604fbb4bfb3eb9cc2">IsActionPressed</a>(0, <span class="stringliteral">&quot;A&quot;</span>)) {</div>
<div class="line">    this.RedColor += 0.1;</div>
<div class="line">    this.BlueColor -= 0.1;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (this.RedColor &gt; 1.0) {</div>
<div class="line">        this.RedColor = 1.0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (this.BlueColor &lt; 0.0) {</div>
<div class="line">        this.BlueColor = 0.0;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_class" href="classInput.html">Input</a>.<a class="code hl_function" href="classInput.html#a345a02f855bdd72604fbb4bfb3eb9cc2">IsActionPressed</a>(0, <span class="stringliteral">&quot;B&quot;</span>)) {</div>
<div class="line">    this.RedColor -= 0.1;</div>
<div class="line">    this.BlueColor += 0.1;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (this.RedColor &lt; 0.0) {</div>
<div class="line">        this.RedColor = 0.0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (this.BlueColor &gt; 1.0) {</div>
<div class="line">        this.BlueColor = 1.0;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>And in <code>Render</code>, replace this line:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#a01c6bc53ee06c86875dc3d225503aa00">SetBlendColor</a>(this.RedColor, this.GreenColor, this.BlueColor, this.AlphaColor);</div>
</div><!-- fragment --><p>...with this line:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classDraw.html">Draw</a>.<a class="code hl_function" href="classDraw.html#a01c6bc53ee06c86875dc3d225503aa00">SetBlendColor</a>(this.Color, 1.0);</div>
</div><!-- fragment --><p>Press F5. The chick should look like this:</p>
<p><img src="tutorial-11.png" alt="The scene with the Hatch logo on it, tinted green" class="inline"/></p>
<p>You can try changing <code>blendColor</code> by opening the scene file in Tiled, or by directly editing <code>scene.tmx</code> in your source code editor, since TMX files are XML documents. You may also experiment adding more properties of different types to the Chick object.</p>
<h2><a class="anchor" id="physics-and-tile-collision"></a>
Physics and tile collision</h2>
<p>Most games need to perform some sort of basic physics simulations, even if it's just for visuals. <a class="el" href="classEntity.html">Entity</a> has fields called <a class="el" href="classEntity.html#a3eb7bebe6e807d404c1df5dfd41ebd49">Entity.XSpeed</a>, <a class="el" href="classEntity.html#af3f00d4c6419ac81c331720f7e792f27">Entity.YSpeed</a>, and <a class="el" href="classEntity.html#a6e43939a579364ab32167e5b1c21c640">Entity.Gravity</a>, which we will use to accomplish basic platformer physics. Eevery frame the <code>Chick</code> will add its gravity value to its vertical speed, and add <a class="el" href="classEntity.html#a3eb7bebe6e807d404c1df5dfd41ebd49">Entity.XSpeed</a> and <a class="el" href="classEntity.html#af3f00d4c6419ac81c331720f7e792f27">Entity.YSpeed</a> to <a class="el" href="classEntity.html#a40628fdcf94fdee28521f384e7f28558">Entity.X</a> and <a class="el" href="classEntity.html#aa7ea4d84d06c8ba4e720ff1ced9445f9">Entity.Y</a>. Hatch performs this automatically if <a class="el" href="classEntity.html#a49acd423e398f63fcee9a9ce73fa80d7">Entity.AutoPhysics</a> is set to <code>true</code>, or if <a class="el" href="classEntity.html#afe42c664dba691ddabbb21291baee8bd">Entity.ApplyMotion</a> is called every frame, but writing your own code always allows you to be more flexible.</p>
<p>By default, <a class="el" href="classEntity.html#a6e43939a579364ab32167e5b1c21c640">Entity.Gravity</a> is <code>0.0</code>, so we need to set it to some value. At the end of <code>Create</code>, add this line:</p>
<div class="fragment"><div class="line"> event Create() {</div>
<div class="line">     [...]</div>
<div class="line">+    this.Gravity = 0.25; // YSpeed increases by 0.25 each frame</div>
<div class="line"> }</div>
</div><!-- fragment --><p>And change the entirety of <code>Update</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">event</span> Update() {</div>
<div class="line">    <span class="keyword">const</span> maxSpeed = 3.0;</div>
<div class="line">    <span class="keyword">const</span> acceleration = 0.5;</div>
<div class="line">    <span class="keyword">const</span> deceleration = 0.25;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_class" href="classInput.html">Input</a>.<a class="code hl_function" href="classInput.html#a779387761a7a9f4eff3928b7d82dd6f8">IsActionHeld</a>(0, <span class="stringliteral">&quot;Left&quot;</span>)) {</div>
<div class="line">        this.XSpeed = <a class="code hl_class" href="classMath.html">Math</a>.<a class="code hl_function" href="classMath.html#ae59c2fe5bb1b2088d168572038c15f98">Clamp</a>(this.XSpeed - acceleration, -maxSpeed, maxSpeed);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_class" href="classInput.html">Input</a>.<a class="code hl_function" href="classInput.html#a779387761a7a9f4eff3928b7d82dd6f8">IsActionHeld</a>(0, <span class="stringliteral">&quot;Right&quot;</span>)) {</div>
<div class="line">        this.XSpeed = <a class="code hl_class" href="classMath.html">Math</a>.<a class="code hl_function" href="classMath.html#ae59c2fe5bb1b2088d168572038c15f98">Clamp</a>(this.XSpeed + acceleration, -maxSpeed, maxSpeed);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.XSpeed &lt; 0.0) {</div>
<div class="line">        this.XSpeed = <a class="code hl_class" href="classMath.html">Math</a>.<a class="code hl_function" href="classMath.html#a5648d54edb049e370f6d422881349c03">Min</a>(this.XSpeed + deceleration, 0.0);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.XSpeed &gt; 0.0) {</div>
<div class="line">        this.XSpeed = <a class="code hl_class" href="classMath.html">Math</a>.<a class="code hl_function" href="classMath.html#aa2c6f1c300138e612e0e7048896e2dae">Max</a>(this.XSpeed - deceleration, 0.0);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    this.YSpeed += this.Gravity;</div>
<div class="line">    this.X += this.XSpeed;</div>
<div class="line">    this.Y += this.YSpeed;</div>
<div class="line">}</div>
<div class="ttc" id="aclassMath_html"><div class="ttname"><a href="classMath.html">Math</a></div><div class="ttdoc">General Math functions.</div><div class="ttdef"><b>Definition</b> Math.dox:8</div></div>
<div class="ttc" id="aclassMath_html_a5648d54edb049e370f6d422881349c03"><div class="ttname"><a href="classMath.html#a5648d54edb049e370f6d422881349c03">Math.Min</a></div><div class="ttdeci">number Min(number a, number b)</div><div class="ttdoc">Gets the lesser value of two Number values.</div></div>
<div class="ttc" id="aclassMath_html_aa2c6f1c300138e612e0e7048896e2dae"><div class="ttname"><a href="classMath.html#aa2c6f1c300138e612e0e7048896e2dae">Math.Max</a></div><div class="ttdeci">number Max(number a, number b)</div><div class="ttdoc">Gets the greater value of two Number values.</div></div>
<div class="ttc" id="aclassMath_html_ae59c2fe5bb1b2088d168572038c15f98"><div class="ttname"><a href="classMath.html#ae59c2fe5bb1b2088d168572038c15f98">Math.Clamp</a></div><div class="ttdeci">number Clamp(number n, number minValue, number maxValue)</div><div class="ttdoc">Gets the value clamped between a range.</div></div>
</div><!-- fragment --><p>This is a basic implementation of acceleration and deceleration physics. Most platformers do something similar.</p>
<p>When you recompile your code, however, the Chick completely falls through the floor:</p>
<p> 
<video controls>
    <source src="tutorial-12.mp4" type="video/mp4">
</video>
</p>
<p>We are missing tile collision detection code, so let's write it. Before we do anything, though, we need to make the scene load tile collision data for the tileset, using <a class="el" href="classScene.html#a992f27b00b03f16c336bf9f5b21e3eca">Scene.LoadTileCollisions</a>. Download the following file and move it into the <code>Resources</code> directory:</p>
<p><a href="collision.bin">collision.bin</a> <br  />
</p>
<p>And in <code>Chick</code>, add the following event:</p>
<div class="fragment"><div class="line"><span class="keyword">event</span> OnSceneLoad() {</div>
<div class="line">    <a class="code hl_class" href="classScene.html">Scene</a>.<a class="code hl_function" href="classScene.html#a992f27b00b03f16c336bf9f5b21e3eca">LoadTileCollisions</a>(<span class="stringliteral">&quot;collision.bin&quot;</span>);</div>
<div class="line">    <a class="code hl_class" href="classScene.html">Scene</a>.<a class="code hl_function" href="classScene.html#aef53c20ad5c54d81f34d730f6ee57f20">SetLayerCollidable</a>(0, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aclassScene_html"><div class="ttname"><a href="classScene.html">Scene</a></div><div class="ttdoc">Functions for manipulating and retrieving information about scenes.</div><div class="ttdef"><b>Definition</b> Scene.dox:8</div></div>
<div class="ttc" id="aclassScene_html_a992f27b00b03f16c336bf9f5b21e3eca"><div class="ttname"><a href="classScene.html#a992f27b00b03f16c336bf9f5b21e3eca">Scene.LoadTileCollisions</a></div><div class="ttdeci">void LoadTileCollisions(string filename, integer tilesetID)</div><div class="ttdoc">Load tile collisions from a resource file.</div></div>
<div class="ttc" id="aclassScene_html_aef53c20ad5c54d81f34d730f6ee57f20"><div class="ttname"><a href="classScene.html#aef53c20ad5c54d81f34d730f6ee57f20">Scene.SetLayerCollidable</a></div><div class="ttdeci">void SetLayerCollidable(integer layerIndex, boolean isVisible)</div><div class="ttdoc">Sets whether the specified layer's tiles can be collided with.</div></div>
</div><!-- fragment --><p>This loads tile collision data that matches our scene's tileset, and disables collision on the background layer. We can now write our tile collision detection code.</p>
<p>The most robust way to do this is using <a class="el" href="classTileCollision.html#ad57112bf2a512e406e1b50811a4444f1">TileCollision.Line</a>. Add this code to <code>Update</code>:</p>
<div class="fragment"><div class="line"> event Update() {</div>
<div class="line">     const maxSpeed = 3.0;</div>
<div class="line">     const acceleration = 0.5;</div>
<div class="line">     const deceleration = 0.25;</div>
<div class="line"> </div>
<div class="line">     if (Input.IsActionHeld(0, &quot;Left&quot;)) {</div>
<div class="line">         this.XSpeed = Math.Clamp(this.XSpeed - acceleration, -maxSpeed, maxSpeed);</div>
<div class="line">     }</div>
<div class="line">     else if (Input.IsActionHeld(0, &quot;Right&quot;)) {</div>
<div class="line">         this.XSpeed = Math.Clamp(this.XSpeed + acceleration, -maxSpeed, maxSpeed);</div>
<div class="line">     }</div>
<div class="line">     else if (this.XSpeed &lt; 0.0) {</div>
<div class="line">         this.XSpeed = Math.Min(this.XSpeed + deceleration, 0.0);</div>
<div class="line">     }</div>
<div class="line">     else if (this.XSpeed &gt; 0.0) {</div>
<div class="line">         this.XSpeed = Math.Max(this.XSpeed - deceleration, 0.0);</div>
<div class="line">     }</div>
<div class="line"> </div>
<div class="line">     this.YSpeed += this.Gravity;</div>
<div class="line">+</div>
<div class="line">+    const lineLength = 32.0;</div>
<div class="line">+    if (TileCollision.Line(this.X + 32.0, this.Y + 32.0, SensorDirection_Down, lineLength, 0, -1, this)) {</div>
<div class="line">+        this.YSpeed = 0.0;</div>
<div class="line">+        this.Y = this.SensorY - 64.0;</div>
<div class="line">+    }</div>
<div class="line">+</div>
<div class="line">     this.X += this.XSpeed;</div>
<div class="line">     this.Y += this.YSpeed;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Press F5. The <code>Chick</code> now properly collides with the floor:</p>
<p> 
<video controls>
    <source src="tutorial-13.mp4" type="video/mp4">
</video>
</p>
<p>One more thing we can add is a jump button: we check if <a class="el" href="classEntity.html#af3f00d4c6419ac81c331720f7e792f27">Entity.YSpeed</a> is zero, and if the <code>A</code> input is being pressed.</p>
<div class="fragment"><div class="line"> event Update() {</div>
<div class="line">     [...]</div>
<div class="line"> </div>
<div class="line">+    if (this.YSpeed == 0.0 &amp;&amp; Input.IsActionPressed(0, &quot;A&quot;)) {</div>
<div class="line">+        this.YSpeed = -6.0;</div>
<div class="line">+    }</div>
<div class="line"> </div>
<div class="line">     this.X += this.XSpeed;</div>
<div class="line">     this.Y += this.YSpeed;</div>
<div class="line"> }</div>
</div><!-- fragment --><p>Press F5. Now you can move the <code>Chick</code> around like in a platformer game:</p>
<p> 
<video controls>
    <source src="tutorial-14.mp4" type="video/mp4">
</video>
</p>
<h2><a class="anchor" id="conclusion"></a>
Conclusion</h2>
<p>This concludes the tutorial! You were introduced to instances and entities, the differences between them, how Hatch connects the engine-side fields and methods of an entity to the code you write, as well as how to draw elements to the screen, poll inputs, load a scene file, and perform basic collision detection.</p>
<p>The tutorial isn't comprehensive in terms of features. You are encouraged to read the Manual to further understand what Hatch can do for you. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
